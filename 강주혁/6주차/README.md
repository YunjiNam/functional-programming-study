# 6주차 - 챕터 10, 11

# 챕터 10 - 일급함수 I

> 코드의 냄새와 중복을 없애 추상화를 잘할 수 있는 리팩토링 방법

## 코드의 냄새

> 더 큰 문제를 가져올 수 있는 코드

함수 이름에 있는 *암묵적 인자*가 코드의 냄새가 된다.

중복 코드가 많은 것도 코드의 냄새가 될 수 있다.

### 특징

1. 거의 똑같이 구현된 함수 있음
2. 함수 이름이 구현에 있는 다른 부분을 가리킴

## 리팩토링: 암묵적 인자 드러내기

> 암묵적 인자가 **일급 값**이 되도록 함수에 인자를 추가

**_일급(first-class) 값?_**  
언어 전체에 어디서나 쓸 수 있는 값. 언어에 있는 다른 값처럼 쓸 수 있다.

1. 함수 이름에 있는 **암묵적 인자** 확인
2. **명시적인 인자** 추가
3. 함수 본문에 하드 코딩된 값을 **새로운 인자**로 바꾸기
4. **함수 호출**하는 곳 수정

일급으로 할 수 있는 것

- 변수 할당
- 함수의 인자로 넘기기
- 함수의 리턴값으로 받기
- 배열이나 객체에 담기

자바스크립트에서 일급이 아닌 것

- 수식 연산자
- 반복문
- 조건문
- try/catch 블록

함수명은 일급이 아니기 때문에, 함수명에 있는 암묵적 인자를 드러내어 일급으로 만들어야 한다.

### 필드명을 문자열로 사용하면 버그가 생길 것 같은데?

해결 방법

1. 컴파일 타임에 검사

주로 정적 타입 시스템에서 사용하는 방법

타입스크립트를 사용하면 컴파일 타임에 검사할 수 있다.

2. 런타임에 검사

함수가 실행할 때마다 동작한다. 전달한 문자열이 올바른 문자열인지 확인한다.

자바스크립트는 정적 타입 언어가 아니기 때문에 런타임에 검사해야 한다.

`includes` 메서드를 사용하여 문자열이 올바른지 확인한다.

### 객체와 배열 너무 많이 쓰게 돼요...

일반적인 엔티티는 객체와 배열처럼 **일반적인 데이터 구조**로 사용해야 한다.

데이터를 데이터 _그대로_ 사용하는 것의 중요한 장점은 **여러 가지 방법으로 해석할 수 있다**는 점이다.

인터페이스로 감싸거나 제한된 API로 정의하면 데이터를 제대로 활용할 수 없다. 필요할 때 알맞은 방법으로 해석할 수 있어야 한다.

-> **_데이터 지향(data orientation)_**

> 이벤트와 엔티티에 대한 사실을 표현하기 위해 일반 데이터 구조를 사용하는 프로그래밍 형식

### 어떤 문법이든 일급 함수로 바꿀 수 있다!

`+ 연산자` 같은 일급이 아닌 것들을 일급 함수로 바꿀 수 있다.

```js
function plus(a, b) {
  return a + b;
}
```

일급으로 만들면 강력한 힘이 생긴다💪

> 고차 함수(higher-order function)  
> : 함수가 다른 함수를 인자로 받을 수 있음

고차 함수를 사용하면 좋은 점

- 코드 추상화할 수 있음

만드는 법

1. 코드를 함수로 감싸기
2. 더 일반적인 이름으로 바꾸기
3. 암묵적 인자를 드러내기
4. 함수 추출하기
5. 암묵적 인자를 드러내기

## 리팩토링: 함수 본문을 콜백으로 바꾸기

> 콜백으로 바꿈으로써 일급 함수로 어떤 함수에 동작을 전달할 수 있음

1. 함수 본문에서 바꿀 부분의 앞부분과 뒷부분을 확인
2. 리팩토링 할 코드를 함수로 빼냄
3. 빼낸 함수의 인자로 넘길 부분을 또 다른 함수로 빼냄

### 함수를 정의하는 방법

1. 전역으로 정의하기
2. 지역적으로 정의하기
3. 인라인으로 정의하기

### 콜백 함수를 사용할 때 주의할 점

함수를 전달해야 한다. 함수로 전달하는 이유는 함수 안에 있는 코드가 특정한문맥 안에서 실행돼야 하기 때문이다.

---

# 챕터 11 - 일급함수 II

## 카피-온-라이트 리팩토링하기

1. 복사본 만들기 (앞부분)
2. 복사본 변경 (본문)
3. 복사본 리턴 (뒷부분)

본문에 해당하는 `복사본 변경` 부분을 콜백으로 빼낸다.

```js
// 리팩토링 전
function arraySet(array, idx, value) {
  const copy = array.slice();
  copy[idx] = value;
  return copy;
}

// 리팩토링 후
function arraySet(array, idx, value) {
  return withArrayCopy(array, (copy) => {
    copy[idx] = value;
  });
}

function withArrayCopy(array, modify) {
  const copy = array.slice();
  modify(copy);
  return copy;
}
```

리팩토링을 통해 코드가 더 길어졌지만, 많은 장점을 얻었다.

1. 표준화된 원칙
2. 새로운 동작에 원칙을 적용할 수 있음
3. 여러 개를 변경할 때 최적화
   - 각각의 카피-온-라이트 함수들을 호출하면 실행할 때마다 새로운 복사본을 만드므로 메모리를 많이 써서 비효율적이다. 콜백을 통해 하나의 복사본을 만들고, 여러 개의 변경을 한 번에 적용할 수 있다.

